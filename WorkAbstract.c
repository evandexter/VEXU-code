#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, driveRight)
#pragma config(Motor,  port2,           centerMotorL,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           centerMotorR,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define leftX Ch4;
#define leftY Ch3;
#define rightX Ch1;
#define rightY Ch2;

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// angles
// where we are
float globalAngle;
// where we want to be
float targetAngle;
void setAngle(float angle);
void addAngle(float angle);

// positions
int globalX, globalY;
int targetX, targetY;
void addPosition(int x, int y);
void setPosition(int x, int y);
void addPositionRelative(int dx, int dy);

// general
void reset();
void clearStates();

// getters


/* base tasks */
void pre_auton() {
	// TODO: starting position

  bStopTasksBetweenModes = true;
}

task autonomous() {
}

task usercontrol() {
  while (true) {
    UserControlCodePlaceholderForTesting();
  }
}

/* additional helper tasks */

// motor controller, determines motor speeds based on target and angle
task motorController() {
}

// tracks the position of the robot and updates robot positions
task positionTracker() {
	// so I don't forget the data type
	tMotor m = leftMotor;
  while(true) {
  	if(nMotorEncoder[leftMotor] > 1000) {
  	}
  	if(nMotorEncoder[rightMotor] > 1000) {
  	}
  	if(nMotorEncoder[centerMotorR] + nMotorEncoder[centerMotorL] > 2000) {
  	}
  }
}

/* general purpose functions */

// resets all data
void reset() {
  clearStates();
}

// resets all targeting state data
void clearStates() {
}

/* logical functions */

/* angles and translations */

// sets the target angle relatively
void addAngle(float angle) {
	targetAngle = globalAngle + angle;
}

// sets the target angle absolutely
void setAngle(float angle) {
	targetAngle = angle;
}

// sets the target position relative to the robots position
void addPosition(int x, int y) {
	targetX = globalX + x;
	targetY = globalY + y;
}

// sets the target position to an absolute point
void setPosition(int x, int y) {
	targetX = x;
	targetY = y;
}

// sets the target position relative to the robots position and facing
void addPositionRelative(int dx, int dy) {
	targetX = globalX + (dx * cosDegrees(globalAngle)) + (dy * sinDegrees(globalAngle));
	targetY = globalY - (dx * sinDegrees(globalAngle)) + (dy * cosDegrees(globalAngle));
}
